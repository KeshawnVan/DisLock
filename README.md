## 背景
### 竞争条件
多个线程依赖某个共享资源，并根据共享资源的值修改该共享资源。由于线程调度的不确定性，MVVC等原因可能会导致出现预期之外的结果。
举个例子，有一家医院要求每个科室每天晚上至少有一个医生值夜班，这一天内科同时有两个医生A和B在值夜班。
A突然有紧急的事情，决定要回家，于是A查看医院的管理系统，发现此时B还在值班，所以A放心的走了。
与此同时B也有急事，也要回家，B打开医院的管理系统，一看A还在值班，B也放心的走了。
这就是一个竞争条件，解决这个问题只需要对读和写加一个互斥锁，保证整个操作是一个原子操作，并且同时只有一个线程可以访问即可。
### 分布式一致性
构建容错系统的最好方法，是找到一些带有实用保证的通用抽象，实现一次，然后让应用依赖这些保证。这与事务处理方法相同：通过使用事务，应用可以假装没有崩溃（原子性），没有其他人同时访问数据库（隔离），存储设备是完全可靠的（持久性）。即使发生崩溃，竞态条件和磁盘故障，事务抽象隐藏了这些问题，因此应用不必担心它们。
现在我们将继续沿着同样的路线前进，寻求可以让应用忽略分布式系统部分问题的抽象概念。例如，分布式系统最重要的抽象之一就是共识（consensus）：就是让所有的节点对某件事达成一致。
## 分布式锁
### 为什么选用Redis实现分布式锁
微服务多个实例之间无法使用Java内置的锁进行互斥，所以需要使用共享的内存，为什么使用RDB实现分布式锁，有以下几个原因：
#### 1.串行化
中间件有好多，为什么要选用Redis呢？其中很大一部分原因是因为Redis的工作线程是单线程的，可以提供串行化的保障。在可串行化的隔离级别下，编写互斥锁是非常容易的。
#### 2.原子命令
只有串行化是不够的，如果命令是分散的，仍然会因为顺序的不确定性导致出现预期外的结果。Redis提供了setNX，lua Script等功能帮助大家实现原子操作
#### 3.持久化
Redis提供多种序列化方式，虽然仍然不能保证数据完全不会丢失，对于锁来说足够了
#### 4.QPS高
很难想想一个串行化的系统的QPS还能这么高，Redis通过以下几点实现高QPS：
* 基于内存
* 很少有耗时操作
* 多路复用

### 实现加锁
用Redis来实现分布式锁最简单的方式就是在实例里创建一个键值（对于已经存在的键值再次声明返回失败），创建出来的键值一般都是有一个超时时间的（这个是Redis自带的超时特性），所以每个锁最终都会释放。
#### 最简单的加锁实现：

```
redisConnection.set(lockKey, NX , PX, expireMsecs)
```
#### 加入获取锁的重试逻辑（在有限的等待时间内重试几次）：

```
    public boolean tryLock() {
        long waitMillis = timeoutMsecs;
	value = UUID.randomUUID().toString();
        while (waitMillis >= 0) {
            long startNanoTime = System.nanoTime();
	    // 尝试获取锁
            String lockResult = setNx();
            locked = OK.equals(lockResult);
	    // 获取到锁或者等待时间为0直接返回结果
            if (locked || waitMillis == 0) return locked;
            int sleepMillis = new Random().nextInt(100);
	    // 没获取到锁，sleep一会儿
            sleep(sleepMillis);
            long escapedMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanoTime);
            waitMillis = waitMillis - escapedMillis;
        }
        return false;
    }
```
### 实现解锁
解锁是一个看似简单的操作，但是如果考虑不周也会存在很多问题
#### 最简单的方案：直接del对应的key
这个方案有什么问题呢？
假如线程A持有了锁，设置了超时时间为1秒，由于GC等各种原因当代码执行到unlock的时候，A的锁已经超时，并且此时该锁已经被B拿到，如果此时A直接delete对应的key，那么就会导致B的锁失效。此时假如有新的线程访问同一个锁，就无法保证互斥。
#### 加锁方记录时间戳
最简单的方式是在加锁方记录一个时间，解锁时判断是否超时，这样其实还是存在一个问题，就是如果还有1ms就要超时了，此时去delete还是有可能把别人的锁删掉，根本原因是由于判断和删除不是一个原子操作。
#### 使用lua script
我们可以在Redis的键值中记录锁的所有者，只有锁的所有者才能删除这个key，并且保证判断和删除是一个原子操作。
Redis提供了执行lua script的功能，帮助我们实现这个原子操作，我们只需要在加锁时指定一个唯一值，并在解锁时使用如下lua script即可实现解锁操作。

```
if redis.call("get",KEYS[1]) == ARGV[1] then
        return redis.call("del",KEYS[1])
    else
        return 0
    end
```
### 一些细节
